Etape 2A Le formulaire HTML de saisie d'une tâche (HTML, CSS uniquement, pas de JS)



Etape 2A : Création du formulaire, HTML et CSS uniquement

Créez un formulaire HTML pour saisir une tâche de la To Do List. Vous pouvez au préalable dessiner sur papier l'allure de votre formulaire, pour le coder ensuite en HTML et CSS (principe d'un Mock-Up, d'une maquette du site web)

Votre formulaire sera adapté pour un support mobile.

Dans cette étape, nous n'abordons pas du tout Javascript, ni les données JSON. C'est un pur formulaire codé en HTML, CSS uniquement. Les listes déroulantes seront codées à la main (pas d'écriture dynamique JS).

Consultez tout de même vos données JSON de l'étape 1 pour en déduire les champs de formulaire dont vous avez besoin, notamment pour le titre d'une tâche, ... , et des listes déroulantes pour vos diverses variables, par ex. la priorité de la tâche, etc... Les options de ces listes sont codées à la main, par ex. pour la priorité, les options pour Important, Pas important, etc..



Quelques conseils :

utiliser le contenu sémantique HTML5 et les éléments sémantiques de mise en page,

ajouter un en-tête avec un titre pour votre To Do List,

ajouter un pied de page avec des informations sur l'auteur (vous), les données de copyright, ...,

ajouter les attributs qui renseignent le contenu attendu d'un champ de formulaire, le cas échéant, et qui rendent la saisie obligatoire,

vous pouvez utiliser CSS Grid et/ou CSS Flexbox, mais pas de framework (pas de Bootstrap, pas de jQuery, ...),

votre page web doit être valide selon le W3C (pour le code HTML, et également pour les CSS)

Cette étape du modèle de formulaire HTML ne contiendra pas de Javascript.

Téléchargez votre fichier sur Alwaysdata, ou PlanetHoster. Déposez l'URL dans la rubrique dépôt 2A.

Etape 3B Approdfndissement : Enregistrer une tâche dans le localStorage

a) Configuration du bouton et gestion du clic

Après avoir saisi les informations d’une nouvelle tâche dans le formulaire, le bouton <button> est utilisé pour enregistrer la tâche.

Ajoutez l’attribut type="button" au bouton <button>. Par défaut, le type est submit, mais ici, nous n’envoyons pas les données vers un serveur (comme dans une application PHP).

Ajoutez l’attribut onclick pour déclencher une fonction JavaScript, par exemple saveTask().

Lorsque l’utilisateur clique sur le bouton, l’événement de clic déclenche la fonction JavaScript.



b) Implémenter la fonction save() selon cette structure

Testez votre code progressivement avec console.log() pour afficher les résultats intermédiaires.



Lecture des champs du formulaire

Utilisez document.getElementById() pour accéder à chaque élément du formulaire via son id.

Chaque élément devient un objet JavaScript, et sa propriété value contient la valeur saisie par l’utilisateur.

Assignez cette valeur à une variable déclarée avec let.

Astuce : utilisez le même nom pour l’id de l’élément et pour la propriété correspondante dans votre structure JSON (ex. : idPriority).
Le champ name n’est pas nécessaire puisqu’il n’y a pas de traitement en back-end.

Remarque :
Si type="submit" est utilisé, le navigateur vérifie automatiquement les champs obligatoires.
Avec type="button", cela n’arrive pas.
Vous pouvez utiliser :

checkValidity() → renvoie true/false,

reportValidity() → affiche les messages d’erreur pour les champs invalides.

Si vous souhaitez les utiliser, consultez MDN WebDocs.

Vous pouvez aussi accéder aux éléments du formulaire via l’API querySelector() avec un sélecteur CSS.

Initialiser la liste des tâches, puis vérifier si des tâches existent déjà dans le localStorage

Définition :
L’API localStorage est un espace de stockage du navigateur permettant d’enregistrer des données sous forme de paires propriété/valeur, conservées même après fermeture du navigateur.
Une clé permet d’identifier les données sauvegardées pour pouvoir les relire.

Déclarez une variable avec let et affectez-lui un tableau vide : ce sera la liste des tâches.

Chaque tâche sera un objet JSON dans le tableau.

Utilisez localStorage.getItem("votreCle") pour vérifier si des tâches ont déjà été enregistrées.

Si des données existent, convertissez-les en tableau JSON avec JSON.parse().

Rappel :
localStorage stocke uniquement des chaînes de caractères, même pour le JSON.
JSON.parse() transforme cette chaîne en objets JavaScript exploitables.

La méthode est statique car elle appartient à la classe JSON elle-même, comme la classe Math.

Consultez MDN WebDocs pour plus d’informations sur parse().

Créer une nouvelle tâche sous forme d'objet JSON

Déterminez l’ID de la nouvelle tâche en comptant les éléments du tableau et en ajoutant 1.
Cela simule un ID auto-incrémenté, comme en MySQL.

Quelle propriété permet de connaître le nombre d’éléments dans un tableau ? → Voir MDN WebDocs.

Créez l’objet représentant la nouvelle tâche avec let.

Affichez-le dans la console pour vérifier que sa structure correspond bien à celle définie à l’étape 1D.

Ajouter la tâche à la liste

Utilisez la méthode push() pour ajouter la nouvelle tâche à la fin du tableau.

Vérifiez le résultat dans la console.

Consultez MDN pour la méthode push().

Enregistrer la liste des tâches dans le localStorage

Convertissez le tableau en chaîne de caractères grâce à la méthode statique JSON.stringify().

Utilisez localStorage.setItem("votreCle", stringData) pour l’enregistrer.

Vérifiez vos données dans les outils de développement du navigateur :
Application → Storage → localStorage.

Vous devez voir vos données dans le tableau clé/valeur, sous forme de tableau JSON d’objets tâche.

Réinitialiser le formulaire pour une nouvelle tâche

Utilisez la méthode reset() pour vider le formulaire.

Accédez à l’élément <form> avec getElementById() puis appelez .reset().

(N’oubliez pas d’ajouter un id au formulaire.)

Etape 3C Approfondissement : Synthèse ou récapitulatif des Tâches

Objectif

Créer une page qui affiche un tableau récapitulatif de toutes les tâches stockées dans le localStorage du navigateur. Vous insérerez dynamiquement ce contenu dans le corps du tableau HTML (<tbody>) une fois que la page aura été entièrement chargée.
Cette page est affichée via un lien provenant du formulaire Web de création de nouvelle tâche.

Instructions étape par étape

A) Point de départ

Pour simplifier, le corps du document, l’élément <body>, contient la structure de base d’un tableau HTML (<table>), avec l’en-tête (<thead>), contenant une ligne <tr> et des cellules d’en-tête <th>.
La liste des tâches sera insérée dans l’élément <tbody>.

Incluez une colonne pour chaque donnée pertinente d’une tâche : titre, priorité, etc.

Rappel : consultez le Table Object Model (T.O.M) pour comprendre la structure d’un tableau HTML avant d’en écrire dynamiquement le contenu.

La page contient également des données JSON liées à certaines variables (par exemple la priorité), déclarées avec let.

B) Lecture des tâches depuis localStorage

Procédez comme dans la page du formulaire Web lors de l’enregistrement d’une nouvelle tâche.

Déclarez un tableau vide avec let pour contenir la liste des tâches.

Lisez le contenu du localStorage en utilisant la méthode getItem() avec la même clé que celle utilisée pour enregistrer les tâches.

Vérifiez si des données existent. Si oui, convertissez-les à nouveau en JSON avec JSON.parse() et affectez-les à votre variable liste de tâches.

Remarque : la variable liste de tâches a une portée globale. Consultez la documentation MDN WebDocs pour comprendre ce que cela signifie.

Affichez le résultat dans la console pour vérifier que les tâches ont bien été récupérées.

C) Attendre que le document soit entièrement chargé

Rappel : lorsqu'une page Web est téléchargée, le head est chargé en premier, puis exécuté. Ce n’est qu’ensuite que le body est chargé.

Donc, si vous essayez d’écrire dynamiquement du contenu dans le body, et particulièrement dans le <tbody> du tableau HTML, vous obtiendrez une erreur : le body n’existe pas encore !

Solution :

Utilisez l’événement document.onreadystatechange pour définir une fonction de rappel (callback).

Dans cette fonction, vérifiez la valeur de document.readyState.

Lorsque cette valeur est "complete", appelez une fonction qui génèrera et insérera les lignes du tableau HTML.

D) Écrire le tableau HTML dynamique

Créez une fonction qui génère le contenu HTML :

Déclarez une variable contenant la chaîne HTML que vous allez construire.

Utilisez des modèles de chaînes (template literals, délimités par les backticks ) et l’interpolation ${...} pour insérer des données dynamiques.

Utilisez la méthode forEach() sur la liste des tâches pour parcourir toutes les tâches.

Rappel : la liste des tâches est un Array, dont chaque élément est une tâche au format JSON.

L’argument de forEach() est une fonction de rappel appliquée à chaque élément.

Pour chaque tâche, récupérez la clé étrangère (l’identifiant recherché, par exemple idPriority) dont vous voulez obtenir la valeur de priorité.

Utilisez la méthode find() sur le tableau correspondant (ex. priorityList) afin de trouver l’objet associé.

Utilisez une fonction fléchée comme callback :
element => element.idPriority == searchedId

Une fois l’objet trouvé, extrayez la propriété souhaitée (ex. priority).

Procédez de la même manière pour les autres variables référencées par un identifiant.

Construisez une ligne <tr> contenant des cellules <td>, une pour chaque propriété pertinente de la tâche.

Insérez le HTML dans le <tbody> (récupéré via getElementById() ou querySelector()) à l’aide de insertAdjacentHTML() avec "beforeend" pour ajouter les lignes à la fin du tableau.

À propos de la méthode find()

La méthode find() sert à rechercher un élément spécifique d’un tableau qui satisfait une condition.
Elle renvoie le premier élément correspondant, ou undefined si rien n’est trouvé.

Elle prend en paramètre une fonction de rappel, appliquée à chaque élément du tableau jusqu’à trouver une correspondance.
Cette fonction doit renvoyer true lorsque la condition est satisfaite.

Exemple de callback pour find() :

currentArrayElement => currentArrayElement.identifier == searchedIdentifier

Ici, on effectue une comparaison avec l’opérateur ==.
Une comparaison retourne toujours un booléen : true si la condition est vraie, false sinon.


Etape 3D Approfondissement : Dernière étape : Archivage des tâches et mise à jour du statut

3D) Dernière étape : Archivage des tâches et mise à jour du statut
La dernière fonctionnalité de ce projet est de permettre la mise à jour du statut d'une tâche, par exemple pour la marquer comme « En cours », « Terminée » ou « Annulée ». Cela améliore le suivi des tâches et permet d’alléger l'affichage en masquant les tâches terminées dans la liste principale.

Objectif :
Ajouter la possibilité de changer le statut d'une tâche, et éventuellement masquer les tâches terminées du tableau principal tout en les conservant en mémoire (dans le localStorage).

Implémentation suggérée

A) Nouvelle colonne dans le tableau des tâches

Ajouter une colonne affichant des boutons de statut pour chaque tâche.

Un bouton, de type type="button", pour chaque statut possible (par exemple : En attente, En cours, Terminée, Annulée), avec un attribut onclick associé pour gérer l’événement de clic.

Le statut actuel doit être visuellement mis en évidence (par exemple par une couleur différente) et désactivé (non cliquable) pour indiquer qu’il est déjà défini.

À la place d’un élément <button>, vous pouvez utiliser un bouton <input type="radio"> personnalisé avec du CSS.

B) Interaction pour la mise à jour du statut

Lorsqu'un utilisateur clique sur un autre bouton de statut :

Une fonction JavaScript est déclenchée : onclick="nomFonction()".

La fonction met à jour le statut de la tâche et rafraîchit l'affichage si nécessaire.

Différentes méthodes existent pour transmettre les informations à la fonction JavaScript :

Chaque bouton peut être de type button avec un attribut onclick, appelant une fonction avec des arguments comme l'ID de la tâche et le nouvel ID de statut : onclick="nomFonction(valeur1, valeur2)".

Sinon, on peut extraire les données à partir des attributs du bouton cliqué (id, data-*, etc.) ou utiliser le DOM pour parcourir les éléments parents ou frères si des attributs ont été définis (voir fin de cette section sur les attributs HTML5 data-*).

C) Gestion du changement de statut en JavaScript
Voici un algorithme possible :

Lire la liste des tâches depuis le localStorage pour être sûr d'avoir la version la plus récente.

Identifier la tâche à partir de son ID.

Utiliser la méthode find() pour localiser l'objet correspondant dans le tableau. Son argument est une fonction de rappel, dont le critère est une comparaison renvoyant vrai ou faux.

Mettre à jour la propriété statut de l’objet trouvé : objet.propriété = nouvelleValeur, c'est-à-dire le nouveau statut sélectionné.

Enregistrer la liste de tâches mise à jour dans le localStorage.

Mettre à jour l'affichage des tâches :

Soit en redessinant tout le tableau,

Soit en ne mettant à jour que les boutons de statut : réinitialiser l'ancien design du bouton et mettre en évidence le nouveau.

Si une tâche est maintenant « Terminée », la retirer de la vue principale du tableau — tout en la conservant dans le localStorage.

D) Fonctionnalités optionnelles (Bonus)
Vous pouvez ajouter des fonctionnalités supplémentaires pour rendre votre projet plus dynamique :

Filtrage des tâches : afficher les tâches selon certains critères (par exemple, par priorité ou par statut).

Afficher les tâches terminées : n’afficher que les tâches ayant le statut « Terminée ».

Tri par date : si vos tâches comportent un champ de date, les afficher triées par date ou filtrer selon une plage de dates.



---------------------------------------------------------

À propos des attributs data-* en HTML5
Les attributs data-* permettent de stocker des données personnalisées directement dans les éléments HTML. Ils sont utiles pour associer des informations supplémentaires à un élément sans en modifier l'apparence ou le comportement par défaut.
Vous pouvez les nommer comme vous voulez, tant que le nom commence par data- suivi d'un nom en minuscules, comme data-task-id ou data-status.

<button data-taskid="42" data-status="inProgress">En cours</button>

En JavaScript, vous pouvez y accéder facilement en utilisant la propriété dataset, en écrivant les noms en camelCase (dataTaskId, dataStatus) :

button.dataset.taskid; // retourne "42"
button.dataset.status; // retourne "inProgress"

Ces attributs sont valides en HTML5 et passent la validation W3C. Ils sont très pratiques dans les projets JavaScript pour stocker des valeurs cachées liées à chaque élément.

